package cg

import (
	"github.com/dianpeng/sql2awk/plan"
)

type tableScanGenRef struct {
	Size  string
	Field string
	Table string
}

type tableScanGen struct {
	cg     *queryCodeGen
	writer *awkWriter
	Ref    []tableScanGenRef
}

func (self *tableScanGen) gencommontab(
	fs string,
	start int,
	end int,
	ts *plan.TableScan,
) error {
	filter := ""
	if ts.Filter != nil {
		filter = self.cg.genExpr(ts.Filter)
	}
	table := ts.Table

	x := tableScanGenRef{
		Table: self.cg.varTable(table.Index),
		Field: self.cg.varTableField(table.Index),
		Size:  self.cg.varTableSize(table.Index),
	}

	// scanning filter code
	{

		self.writer.Line(
			`FS = "%[fs]";`,
			awkWriterCtx{
				"fs": fs,
			},
		)

		if start > 0 {
			self.writer.Line(
				`if (FNR <= %[start]) next`,
				awkWriterCtx{
					"start": start,
				},
			)
		}

		if end > 0 {
			self.writer.Line(
				`if (FNR > %[end]) nextfile;`,
				awkWriterCtx{
					"end": end,
				},
			)
		}
	}

	// rewrite
	if rewrite := table.Rewrite; rewrite != nil {
		for _, stmt := range rewrite.Stmt {
			self.writer.If(
				"%[cond]",
				awkWriterCtx{
					"cond": self.cg.genExpr(stmt.Cond),
				},
			)

			if len(stmt.Set) > 0 {
				// We purposely split the rewriting phase into 2 separate loops, instead
				// of modifying the column field in place. The reason is as following,
				// assume user writing following code:
				//
				// rewrite
				//   when $1 == 100 then set $1 = 20, $2=$1
				// ...
				// The second assignment depends on $1, which is modified in first when
				// clause. If we allowed the modification of first clause to be reflected
				// inside of the second assignment, this means there's an execution order
				// of all the when clause, which is not something we want, and we should
				// not. Instead, we do not have any forced order of execution for all the
				// clause in rewrite stage. Therefore, the second assignment of $2 should
				// see $1's value before modification.
				//
				// To address this issue, we have 2 separate loops. The first loop will
				// do the modification and set the modified value into *temporary*
				// local variables, and then the second 2 loop will move the temporary
				// value into its final destination directly.

				for _, set := range stmt.Set {
					self.writer.Line(
						"%[tmp] = %[value];",
						awkWriterCtx{
							"idx":   set.Column,
							"tmp":   self.writer.LocalN("tmp_value", set.Column),
							"value": self.cg.genExpr(set.Value),
						},
					)
				}

				for _, set := range stmt.Set {
					self.writer.Line(
						"$%[idx] = %[tmp];",
						awkWriterCtx{
							"idx": set.Column,
							"tmp": self.writer.LocalN("tmp_value", set.Column),
						},
					)
				}
			} else {
				self.writer.Line("next;", nil)
			}
			self.writer.IfEnd()
		}
	}

	// table gen
	{
		// Filter generation.
		//
		// Totally, we have 3 types of filters to be applied, the order does not
		// really matter, since they are targetting at various respect of the table

		// 1) Early filter, which is generated by planner to allow early filter of
		//    rows that is not irrelevent

		// 2) Row filter, which is specified by select extension
		// 3) Col filter, which is specified by select extension

		// *** early filter generation, if applicable ***
		if filter != "" {

			self.writer.Line(
				`if (!(%[filter])) next;`,
				awkWriterCtx{
					"filter": filter,
				},
			)
		}

		// *** row filter generation, if applicable ***
		if ts.RowFilter != nil {
			rFilter := ts.RowFilter // using regex here
			self.writer.Line(
				`if (!($0 ~ /%[r]/)) next;`,
				awkWriterCtx{
					"r": rFilter.Pattern,
				},
			)
		}

		// *** col filter generation, if applicable ***
		if ts.ColFilter != nil {

			// The column filter will *modify* NF and $1 value, accordingly, the
			// algorithm is kind of simple, we scan all the choped column from $1
			// to $NF, and keep a counter for modification purpose
			self.writer.Chunk(
				`
$[l, mod_idx] = 1; # modification purpose
for ($[l, cf_i] = 1; $[l, cf_i] <= NF; $[l, cf_i]++) {
  if (!($$[l, cf_i] ~ /%[r]/)) continue;
  $$[l, mod_idx] = $$[l, cf_i];
  $[l, mod_idx]++;
}
NF = $[l, mod_idx] - 1;
`,
				awkWriterCtx{
					"r": ts.ColFilter.Pattern,
				},
			)
		}

		// Fitlers are done
		// -----------------------------------------------------------------------

		self.writer.Chunk(
			`
row_idx = %[table_size];
%[table_size]++;
`,
			awkWriterCtx{
				"table":      x.Table,
				"table_size": x.Size,
			},
		)

		if !table.FullColumn {
			self.writer.Line(
				`field_count_tt = %[max_column] < NF ? %[max_column] : NF;`,
				awkWriterCtx{
					"max_column": table.MaxColumn,
				},
			)
		} else {
			self.writer.Line("field_count_tt = NF;", nil)
		}

		self.writer.Chunk(
			`
if (%[table_field] < field_count_tt) {
  %[table_field] = field_count_tt;
}

# make sure include special field index (0), ie the fullline
for (i = 0; i <= field_count_tt; i++) {
  %[table][row_idx, i] = $i;
}

# special field to contain column size, if needed for the future
%[table][row_idx, "$"] = NF;
next;
`,
			awkWriterCtx{
				"table":       x.Table,
				"table_size":  x.Size,
				"table_field": x.Field,
			},
		)
	}

	self.Ref = append(self.Ref, x)
	return nil
}

func (self *tableScanGen) genTableTab(
	ts *plan.TableScan,
) error {
	fs := ts.Table.Params.AsStr(0, " ")
	start := ts.Table.Params.AsInt(1, -1)
	end := ts.Table.Params.AsInt(2, -1)
	self.writer.If(
		`FILENAME=="%[filename]"`,
		awkWriterCtx{
			"filename": ts.Table.Path,
		},
	)
	defer func() {
		self.writer.IfEnd()
	}()

	self.writer.Chunk(
		`
if (FNR == 1) {
  # always the first line have the issue, we will *NOT* use NF, but
  # use manual split hera, notes the FS will be treated as static regexp
  # whose type will not touch the split function implementation bug, which
  # not always use regexp search :(
  reparse_tab($0, "%[fs]");
}
`,
		awkWriterCtx{
			"fs": fs,
		},
	)

	return self.gencommontab(fs, start, end, ts)
}

func (self *tableScanGen) genTableXSV(
	ts *plan.TableScan,
) error {
	delim := ts.Table.Params.AsStr(0, ",")
	start := ts.Table.Params.AsInt(1, -1)
	end := ts.Table.Params.AsInt(2, -1)

	self.writer.If(
		`FILENAME=="%[filename]"`,
		awkWriterCtx{
			"filename": ts.Table.Path,
		},
	)

	defer func() {
		self.writer.IfEnd()
	}()

	// before entering into the code, we need to *parse the line* as CSV
	self.writer.Chunk(
		`
# TODO(dpeng): add broken CSV record handling customization here
$[l, csv_len] = xsv_parse_line($0, 1, "%[delim]", $[l, csv_out]);
for ($[l, csv_i] = 1; $[l, csv_i] <= $[l, csv_len]; $[l, csv_i]++) {
  $$[l, csv_i] = $[l, csv_out][$[l, csv_i]];
}
FR = $[l, csv_len];
`,
		awkWriterCtx{
			"delim": delim,
		},
	)

	return self.gencommontab("", start, end, ts)
}

func (self *tableScanGen) gen(
	p *plan.Plan,
) error {
	for _, ts := range p.TableScan {
		switch ts.Table.Type {
		case "tab", "Tab":
			if err := self.genTableTab(ts); err != nil {
				return err
			}
			break
		case "csv", "xsv":
			if err := self.genTableXSV(ts); err != nil {
				return err
			}
			break

		default:
			panic("unknown table type")
			break
		}
	}
	return nil
}
